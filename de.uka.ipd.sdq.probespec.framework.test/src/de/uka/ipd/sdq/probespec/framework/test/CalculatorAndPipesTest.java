package de.uka.ipd.sdq.probespec.framework.test;

import java.util.Vector;

import javax.measure.quantity.Quantity;

import junit.framework.TestCase;
import de.uka.ipd.sdq.pipesandfilters.framework.MetaDataInit;
import de.uka.ipd.sdq.pipesandfilters.framework.PipesAndFiltersManager;
import de.uka.ipd.sdq.pipesandfilters.framework.edp2.EDP2MetaDataInit;
import de.uka.ipd.sdq.pipesandfilters.framework.filters.ExampleFilter;
import de.uka.ipd.sdq.pipesandfilters.framework.recorder.ConsoleWriteStrategy;
import de.uka.ipd.sdq.pipesandfilters.framework.recorder.IRawWriteStrategy;
import de.uka.ipd.sdq.pipesandfilters.framework.recorder.RawRecorder;
import de.uka.ipd.sdq.probespec.framework.ProbeSample;
import de.uka.ipd.sdq.probespec.framework.ProbeSetSample;
import de.uka.ipd.sdq.probespec.framework.RequestContext;
import de.uka.ipd.sdq.probespec.framework.SampleBlackboard;
import de.uka.ipd.sdq.probespec.framework.calculator.ResponseTimeCalculator;
import de.uka.ipd.sdq.probespec.framework.probes.example.ExampleProbeStrategyRegistry;
import de.uka.ipd.sdq.probespec.framework.probes.example.SimpleSimulationContext;

/**
 * This test case demonstrates the functioning of the ProbeSpec framework.
 * Therefore a very simple architecture model consisting of two model entities
 * is used. Each of them is annotated by a ProbeSet containing a
 * CurrentTimeProbe. A ResponseTimeCalculator will then calculate the time span
 * between both points of time in order to obtain the response time. In the end
 * the result is passed to a Pipes-and-Filters chain.
 * <p>
 * <img src="doc-files/calcandpipes.png" width="750">
 * <p>
 * As shown in the picture a fictitious request with the RequestContextID "1" is
 * measured. It passes Component 1 at the time t=100ms and Component 2 at the
 * time t=154ms. Afterwards both ProbeSetSamples are published on the blackboard
 * and the ResponseTimeCalculator is notified. As soon as both ProbeSetSamples
 * are available the difference is calculated and the result tuple is passed to
 * the Pipes-and-Filters chain.
 * 
 * @author pmerkle
 * @author Faber
 * 
 */
public class CalculatorAndPipesTest extends TestCase {

	private SimpleSimulationContext simCtx;

	private SampleBlackboard blackboard;

	private ExampleFilter filter;

	private IRawWriteStrategy writeStrategy;

	private RawRecorder recorder;

	private PipesAndFiltersManager manager;

	private ResponseTimeCalculator calc1;

	@Override
	protected void setUp() throws Exception {
		super.setUp();

		simCtx = new SimpleSimulationContext();

		// Code generated by the transformation that builds up the filter chain:
		// GENERATED CODE BY PIPES AND FILTERS TRANSFORMATION - START
		filter = new ExampleFilter();
		writeStrategy = new ConsoleWriteStrategy();
		recorder = new RawRecorder(writeStrategy);
		manager = new PipesAndFiltersManager(filter);
		manager.addElement(recorder);
		manager.addConnection(filter, recorder);
		// GENERATED CODE BY PIPES AND FILTERS TRANSFORMATION - END

		// The following code is generated by the transformation to create
		// instances for all pipe and filter elements, for the calculators.
		// Afterwards the pipes are initialized with the correct meta data.
		// GENERATED CODE BY PROBE SPEC TRANSFORMATION - START
		blackboard = new SampleBlackboard();
		factory = new ExampleProbeStrategyRegistry(simCtx);
		initializeCalculators();
		// Create a description of our calculator (the measured object)
		MetaDataInit metaInit = new EDP2MetaDataInit(calc1
				.getMeasurementMetrics());
		metaInit.setExperimentName("Experiment 1");
		metaInit.setMeasurementName("Calculator 1");
		calc1.setPipesAndFiltersManager(manager);
		manager.initialize(metaInit);
		// GENERATED CODE BY PROBE SPEC TRANSFORMATION - END

	}

	// GENERATED CODE BY PROBE SPEC TRANSFORMATION - START
	private void initializeCalculators() {
		calc1 = new ResponseTimeCalculator(blackboard, "ProbeSetID_1",
				"ProbeSetID_2");
	}

	// GENERATED CODE BY PROBE SPEC TRANSFORMATION - END

	public void testSimulation() {

		simCtx.setSimulatedTime(100);
		// This code will later be the generated code from the transformation.
		// For each Probe and ProbeSet such a code is added to the simulation
		// code. By adding the ProbeSetSample to the SampleBlackboard the
		// Calculators are informed (Observer pattern) and do their
		// calculations.
		// GENERATED CODE BY PROBE SPEC TRANSFORMATION - START
		Vector<ProbeSample<?, ? extends Quantity>> psv1 = new Vector<ProbeSample<?, ? extends Quantity>>();
		psv1.add(factory.getTakeCurrentTime().takeSample("theProbeID_1"));
		ProbeSetSample pss1 = new ProbeSetSample(psv1,
				new RequestContext("1"), "Model_1", "ProbeSetID_1");
		pss1.addToTimeToLive(1);
		blackboard.addSample(pss1);
		// GENERATED CODE BY PROBE SPEC TRANSFORMATION - END

		simCtx.setSimulatedTime(154);
		// GENERATED CODE BY PROBE SPEC TRANSFORMATION - START
		Vector<ProbeSample<?, ? extends Quantity>> psv2 = new Vector<ProbeSample<?, ? extends Quantity>>();
		psv2.add(factory.getTakeCurrentTime().takeSample("theProbeID_2"));
		ProbeSetSample pss2 = new ProbeSetSample(psv2,
				new RequestContext("1"), "Model_2", "ProbeSetID_2");
		blackboard.addSample(pss2);
		// GENERATED CODE BY PROBE SPEC TRANSFORMATION - END

		// This cast is necessary to get the lastArrivedPipeData. The standard
		// filter interface does not support such a method.
		ExampleFilter exFilter = (ExampleFilter) manager.getStartElement();

		// Assert checks if the Calculator supplies the right time difference.
		// Note that the context sets the current time in seconds. But the
		// Calculator returns the result in milliseconds. Nevertheless JScience
		// allows arbitrary conversions between the units.
		assertEquals(Long.valueOf(54), (Long) exFilter.getLastArrivedData()
				.getTupleElement(0).getValue());

	}

	@Override
	protected void tearDown() throws Exception {
		super.tearDown();
		manager.finalize();
	}

}
